= Fundamentos test unitarios
:icons: font
:twitter-tag: BPS
:conference-tag:
:talk-tag: Unit test
:slide-link: http://bit.ly/intro-unit-test
:demo-link:
:linkattrs:

include::footer.ad[]

[NOTE.speaker]
====
Contenido de la presentación:

*	Secciones teóricas:
**	Fundamentos. ¿Por qué usar test unitarios? Refactoring. Buenas prácticas. Niveles de test/Requisitos, Code coverage.
**	Testing doubles. Manejo de dependencias. Dummies, Stubs, Fakes, Spies, Mocks. Prácticas recomendadas.
*	TDD. Prácticas para mejorar los test. Red-Green-Refactor cycle. Ventajas y Desventajas.
*	Secciones prácticas:
**	Herramientas. JUnit – Annotations / Lifecycle. Prácticas. Mockito/Powermock. Hamcrest/Assertj.
**	TDD Kata.

====
//== !
//image::pattern-design-4pwbdv1y.jpg[background, size=auto]
// Fuente: https://standaserigraf.wordpress.com/2015/09/30/pattern-design-tecnica-artistica-que-se-ocupa-de-la-creacion-de-patrones-graficos/

== Contenido
* Fundamentos
* Testing doubles
* TDD
* Herramientas

== ¿Por qué escribimos tests? icon:lightbulb[]

== ¿Por qué escribimos tests?
* Para asegurarnos que el código funciona
* ... pero escribir test automatizados es mucho más trabajo que simplemente escribir el `main` y validar entradas y salidas ...

== El software cambia icon:code[]

* Si el software cambia, los test deben cambiar con él
* Si cambiamos la estructura de nuestras clases, tenemos que adaptar los test, perder tiempo
* Si añadimos nuevas funcionalidades obviamente no vamos a tener tests
* Si arreglamos icon:bug[], al principio no vamos a tener test

== Refactoring icon:magic[]

No todos los cambios son funcionales

*Refactor* -- Proceso de de reestructurar un código fuente, alterando su estructura interna sin cambiar su comportamiento externo.

== Razones para hacer refactoring icon:magic[]
* Reparar problemas en el código (code smells)
* Pagar deuda técnica
* Mejorar rendimiento
* Actualizar API
* ...

== !
image::refactor-catalog.PNG[background, size=auto]
//Fuente: https://refactoring.com/catalog/

== Estrategias para hacer refactoring icon:magic[]
. Preparar el código para la nueva funcionalidad
. Añadir la nueva funcionalidad

== ¿Cuándo hacer refactoring icon:magic[]?
. Debería ser algo de todos los días
. Los IDEs ayudan a automatizar de manera segura refactors simples

== Regla del Boyscout
image::boy-scout-rule.jpeg[background, size=auto]
//Fuente: https://medium.com/@biratkirat/step-8-the-boy-scout-rule-robert-c-martin-uncle-bob-9ac839778385

== Refactors inseguros icon:exclamation-triangle[]
No todos los refactors son seguros:

* Inlining (efectos secundarios)
* Cambiar dependencias
* Cambiar algoritmos o estructuras de datos
* ... Cualquier cambio no trivial

== Refactors seguros icon:check[]

Para hacer refactor seguros, *tenemos que escribir tests*

No escribimos tests para asegurarnos que el código funcione

Escribimos test para asegurarnos que siga funcionando

== Usar tests:check[]
Si no se escriben test se crea *código legacy*.

image::legacy-code-sequence.PNG[]
Es una relación *cíclica*.

== Ciclo de refactor malo
image::bad-refactoring-cycle.PNG[background, size=auto]

== Ciclo de refactor bueno
image::good-refactoring-cycle.PNG[background, size=auto]

== Otras razones para hacer test

* Es una prueba de que el código funciona.
* Son una fuente de documentación, muestran las intenciones del código.
* Mejoran el diseño de la aplicación.

== Niveles de test

* Unit tests
* Integration tests
* End to End tests
* Acceptance / Business logic tests

[NOTE.speaker]
====
* Unit tests: Prueban una sola unidad del sistema. No tienen dependencias de los componentes externos del sistema BD, WS, API. Falsifican sus dependencias.
* Integration tests: Verifica que grupos de unidades puedan trabajar juntas correctamente.
* End-to-End tests: Prueba flujos completos de interacciones en el sistema. Se puede considerar como extensión de los test de integración. Tiene dependencias reales a los componentes del sistema, BD, WS, APIs.
* Acceptance / Business logic tests: Buscan responder la pregunta, ¿construimos lo que el cliente esperaba? Normalmente se centra en la historia del usuario y usan el lenguaje del negocio.
====

== ¿Qué porcentaje debo cubrir?

* 70% Unit tests
* 20% Integration
* 10%  End to End tests

== ¿Qué es una unidad?

* Una clase (la mayoría de las veces)
* Muchas clases relacionadas
* Un paquete. Usualmente solo se prueba el API público, la interna y privada se prueba de manera implícita.

== Requisitos de un test

* Rápido
* Coherente
* Modular
* Independiente de la implementación

[NOTE.speaker]
====
* Rápido: Los tests unitarios deben ejecutarse rápidamente. Entre más pronto y frecuente se ejecuten, más temprano se van a detectar las fallas y corregirse.
Los tiempos de ejecución deben estar en el orden de los milisegundos. No deben tener acceso I/O y sus entradas deben ser las mínimas necesarias.
* Coherente: Leer test deben poderse leer de manera fácil. La idea es que revelen las intenciones del código de producción.
 Pueden ser usados como documentación. Deben estar escritos de manera estructurada y consistente.
* Modular: Unidad debe ser lo más pequeña posible. El objetivo es buscar que los test sean lo más pequeño posible también.
 Se prefiere escribir muchos pequeños test que grandes tests. En lo posible buscar tener un solo asssert por test (Pueden ser múltiples cuando se validan datos).
  Los test usualmente no deberían fallar por un problema en las dependencias.
* Independiente de la implementación: Los test deben validar la salida con respecto a una entrada.
Normalmente no se debe cambiar un test si la implementación cambia, solo se hace si cambia la funcionalidad externa.
  Se debe evitar escribir test que simplemente repitan el código de producción. El objetivo de los test es facilitar el refactor.
  Preferir en lo posible test de caja negra que de caja blanca.
** Caja negra: Se prueba la funcionalidad sin conocer su implementación.
** Caja blanca: Se prueba conociendo los detalles de la implementación.
====

== Estructura de un test
1. Arrange (Planificación)
2. Act (Acción)
3. Assert (Afirmación)

== !
[source, java]
----
@Test
public void givenString_whenReverse_getReverseString() {
  String input = "abc"; // <1>

  String result = StringUtils.reverse(input); //<2>

  assertThat(result).isEqualTo("cba"); //<3>
}
----

== Buenas Prácticas
* Evitar repetir código de producción.
* Se debe evitar escribir lógica en los test.
* Agregar al menos un test cuando se soluciona una falla.

[NOTE.speaker]
====
* El código de producción describe una solución general.
* El código del test es concreto.
* Se recomienda especificar entradas y salidas concretas en los test.
====

== Buenas Prácticas
* Evitar hacer test de métodos privados. Se debe probar las interfaces no las implementaciones.
* Antes de pasar, los test deben fallar.

[NOTE.speaker]
====
* Si se requiere probar un método privado se recomienda, extraer a una clase o en última instancia cambiar a package-private.
====

== ¿Los test nos hace lentos?
* Los test nos ayudan a conseguir fallos. Por lo tanto, se introducen menos fallos.
* Nos permite agregar cambios con confianza. Mejora la productividad.

== Conclusiones

include::self.ad[]
